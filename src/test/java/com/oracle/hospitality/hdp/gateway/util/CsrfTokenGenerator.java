package com.oracle.hospitality.hdp.gateway.util;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.time.Instant;
import java.util.Base64;
import java.util.Date;
import java.util.HexFormat;
import java.util.UUID;

/**
 * Utility class for generating CSRF tokens for testing purposes.
 * 
 * This class is for TESTING ONLY and should not be used in production.
 * In production, tokens should be generated by a separate token-issuing
 * service.
 * 
 * Usage:
 * 
 * <pre>
 * String token = CsrfTokenGenerator.generateToken(
 *         "path/to/private-key.pem",
 *         "john.doe",
 *         "session-123",
 *         "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36");
 * </pre>
 */
public class CsrfTokenGenerator {

    private static final String DEFAULT_ISSUER = "hdp-csrf-issuer";
    private static final int DEFAULT_TTL_SECONDS = 600; // 10 minutes

    /**
     * Generates a CSRF token for testing.
     *
     * @param privateKeyPath Path to the private key PEM file
     * @param username       Username (sub claim)
     * @param sessionId      Session ID
     * @param userAgent      User-Agent string
     * @return JWT token string
     * @throws Exception if token generation fails
     */
    public static String generateToken(
            String privateKeyPath,
            String username,
            String sessionId,
            String userAgent) throws Exception {

        return generateToken(privateKeyPath, username, sessionId, userAgent, DEFAULT_ISSUER, DEFAULT_TTL_SECONDS);
    }

    /**
     * Generates a CSRF token with custom issuer and TTL.
     *
     * @param privateKeyPath Path to the private key PEM file
     * @param username       Username (sub claim)
     * @param sessionId      Session ID
     * @param userAgent      User-Agent string
     * @param issuer         Issuer claim
     * @param ttlSeconds     Time-to-live in seconds
     * @return JWT token string
     * @throws Exception if token generation fails
     */
    public static String generateToken(
            String privateKeyPath,
            String username,
            String sessionId,
            String userAgent,
            String issuer,
            int ttlSeconds) throws Exception {

        PrivateKey privateKey = loadPrivateKey(privateKeyPath);
        String userAgentHash = hashUserAgent(userAgent);
        Instant now = Instant.now();

        return Jwts.builder()
                .issuer(issuer)
                .subject(username)
                .claim("session_id", sessionId)
                .claim("user_agent_hash", userAgentHash)
                .issuedAt(Date.from(now))
                .expiration(Date.from(now.plusSeconds(ttlSeconds)))
                .id(UUID.randomUUID().toString())
                .signWith(privateKey, SignatureAlgorithm.RS256)
                .compact();
    }

    /**
     * Loads a private key from a PEM file.
     *
     * @param path Path to the PEM file
     * @return PrivateKey object
     * @throws IOException if file cannot be read
     * @throws Exception   if key parsing fails
     */
    private static PrivateKey loadPrivateKey(String path) throws Exception {
        String pemContent = Files.readString(Paths.get(path), StandardCharsets.UTF_8);

        String privateKeyPEM = pemContent
                .replace("-----BEGIN PRIVATE KEY-----", "")
                .replace("-----END PRIVATE KEY-----", "")
                .replaceAll("\\s+", "");

        byte[] encoded = Base64.getDecoder().decode(privateKeyPEM);
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");

        return keyFactory.generatePrivate(keySpec);
    }

    /**
     * Hashes a User-Agent string using SHA-256.
     *
     * @param userAgent User-Agent string
     * @return Hex-encoded SHA-256 hash
     */
    private static String hashUserAgent(String userAgent) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(userAgent.getBytes(StandardCharsets.UTF_8));
            return HexFormat.of().formatHex(hash);
        } catch (Exception e) {
            throw new RuntimeException("Failed to hash User-Agent", e);
        }
    }

    /**
     * Main method for command-line token generation.
     * 
     * Usage:
     * java CsrfTokenGenerator <private-key-path> <username> <session-id>
     * <user-agent>
     */
    public static void main(String[] args) {
        if (args.length < 4) {
            System.err
                    .println("Usage: java CsrfTokenGenerator <private-key-path> <username> <session-id> <user-agent>");
            System.err.println("Example: java CsrfTokenGenerator keys/private.pem john.doe sess-123 \"Mozilla/5.0\"");
            System.exit(1);
        }

        try {
            String token = generateToken(args[0], args[1], args[2], args[3]);
            System.out.println("Generated CSRF Token:");
            System.out.println(token);
            System.out.println();
            System.out.println("Use in request:");
            System.out.println("curl -X POST http://localhost:8080/api/test \\");
            System.out.println("  -H \"X-CSRF-Token: " + token + "\" \\");
            System.out.println("  -H \"idcs_remote_user: " + args[1] + "\" \\");
            System.out.println("  -H \"idcs_session_id: " + args[2] + "\" \\");
            System.out.println("  -H \"User-Agent: " + args[3] + "\" \\");
            System.out.println("  -H \"Cookie: session=test\"");
        } catch (Exception e) {
            System.err.println("Error generating token: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
}
